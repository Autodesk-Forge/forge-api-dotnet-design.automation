/* 
 * Forge SDK
 *
 * The Forge Platform contains an expanding collection of web service components that can be used with Autodesk cloud-based products or your own technologies. Take advantage of Autodeskâ€™s expertise in design and engineering.
 *
 * Design Automation
 *
 * Generated by [Forge Swagger Codegen](https://git.autodesk.com/forge-ozone/forge-rsdk-codegen)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
using Autodesk.Forge.Core;
using Microsoft.Extensions.Options;
using System.Collections.Generic;
using System.Net.Http;
using Autodesk.Forge.DesignAutomation.Rsdk.Model;

namespace Autodesk.Forge.DesignAutomation.Rsdk.Http
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IWorkItemsApi
    {
        /// <summary>
        /// Creates a new WorkItem and queues it for processing. Creates a new WorkItem and queues it for processing.  The new WorkItem is always placed on the  queue; no further action is necessary.                Limits (Engine-specific):                1. Number of downloads (LimitDownloads)  2. Number of uploads (LimitUploads)  3. Total download size (LimitDownloadSize)  4. Total upload size (LimitUploadSize)  5. Processing time (LimitProcessingTime)  6. Total size of uncompressed bits for all referenced appbundles (LimitTotalUncompressedAppsSizePerActivity).
        /// </summary>
        /// <exception cref="HttpRequestException">Thrown when fails to make API call</exception>
        /// <param name="workitem"></param>
        /// <returns>Task of ApiResponse<WorkItemStatus></returns>
        
        System.Threading.Tasks.Task<ApiResponse<WorkItemStatus>> CreateWorkItemsAsync (WorkItem workitem, string scopes = null, IDictionary<string, string> headers = null, bool throwOnError = true);
        /// <summary>
        /// Cancels a specific WorkItem. Cancels a specific WorkItem.  If the WorkItem is on the queue, it is removed from the queue and not processed.  If the WorkItem is already being processed, then it may or may not be interrupted and cancelled.  If the WorkItem has already finished processing, then it has no effect on the processing or results.
        /// </summary>
        /// <exception cref="HttpRequestException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        
        /// <returns>Task of HttpResponseMessage</returns>
        System.Threading.Tasks.Task<HttpResponseMessage> DeleteWorkitemAsync (string id, string scopes = null, IDictionary<string, string> headers = null, bool throwOnError = true);
        /// <summary>
        /// Gets the status of a specific WorkItem. Gets the status of a specific WorkItem.  Typically used to &#39;poll&#39; for              the completion of a WorkItem, but see the use of the &#39;onComplete&#39; argument for              an alternative that does not require &#39;polling&#39;.  WorkItem status is retained              for a limited period of time after the WorkItem completes.              Limits:              1. Retention period (LimitWorkItemRetentionPeriod).
        /// </summary>
        /// <exception cref="HttpRequestException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>Task of ApiResponse<WorkItemStatus></returns>
        
        System.Threading.Tasks.Task<ApiResponse<WorkItemStatus>> GetWorkitemStatusAsync (string id, string scopes = null, IDictionary<string, string> headers = null, bool throwOnError = true);
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class WorkItemsApi : IWorkItemsApi
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="WorkItemsApi"/> class
        /// using ForgeService object
        /// </summary>
        /// <param name="service">An instance of ForgeService</param>
        /// <returns></returns>
        public WorkItemsApi(ForgeService service = null, IOptions<Configuration> configuration = null)
        {
            this.Service = service ?? ForgeService.CreateDefault();

            // set BaseAddress from configuration or default
            this.Service.Client.BaseAddress = configuration?.Value.BaseAddress ?? new Configuration().BaseAddress;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the ForgeService</value>
        public ForgeService Service {get; set;}

        /// <summary>
        /// Creates a new WorkItem and queues it for processing. Creates a new WorkItem and queues it for processing.  The new WorkItem is always placed on the  queue; no further action is necessary.                Limits (Engine-specific):                1. Number of downloads (LimitDownloads)  2. Number of uploads (LimitUploads)  3. Total download size (LimitDownloadSize)  4. Total upload size (LimitUploadSize)  5. Processing time (LimitProcessingTime)  6. Total size of uncompressed bits for all referenced appbundles (LimitTotalUncompressedAppsSizePerActivity).
        /// </summary>
        /// <exception cref="HttpRequestException">Thrown when fails to make API call</exception>
        /// <param name="workitem"></param>
        /// <returns>Task of ApiResponse<WorkItemStatus></returns>
        
        public async System.Threading.Tasks.Task<ApiResponse<WorkItemStatus>> CreateWorkItemsAsync (WorkItem workitem, string scopes = null, IDictionary<string, string> headers = null, bool throwOnError = true)
        {
            using (var request = new HttpRequestMessage())
            {
                request.RequestUri = 
                    Marshalling.BuildRequestUri("/v3/workitems", 
                        routeParameters: new Dictionary<string, object> {
                        },
                        queryParameters: new Dictionary<string, object> {
                        }
                    );

                request.Headers.TryAddWithoutValidation("Accept", "application/json");
                if (headers!=null)
                {
                    foreach (var header in headers)
                    {
                        request.Headers.TryAddWithoutValidation(header.Key, header.Value);
                    }
                }

                request.Content = Marshalling.Serialize(workitem); // http body (model) parameter

                // tell the underlying pipeline what scope we'd like to use
                if (scopes == null)
                {
                    request.Properties.Add(ForgeConfiguration.ScopeKey, "code:all");
                }
                else
                {
                    request.Properties.Add(ForgeConfiguration.ScopeKey, scopes);
                }

                request.Method = new HttpMethod("POST");

                // make the HTTP request
                var response = await this.Service.Client.SendAsync(request);

                if (throwOnError)
                {
                    await response.EnsureSuccessStatusCodeAsync();
                }
                else if (!response.IsSuccessStatusCode)
                {
                    return new ApiResponse<WorkItemStatus>(response, default(WorkItemStatus));
                }

                return new ApiResponse<WorkItemStatus>(response, await Marshalling.DeserializeAsync<WorkItemStatus>(response.Content));

            } // using
        }
        /// <summary>
        /// Cancels a specific WorkItem. Cancels a specific WorkItem.  If the WorkItem is on the queue, it is removed from the queue and not processed.  If the WorkItem is already being processed, then it may or may not be interrupted and cancelled.  If the WorkItem has already finished processing, then it has no effect on the processing or results.
        /// </summary>
        /// <exception cref="HttpRequestException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        
        /// <returns>Task of HttpResponseMessage</returns>
        public async System.Threading.Tasks.Task<HttpResponseMessage> DeleteWorkitemAsync (string id, string scopes = null, IDictionary<string, string> headers = null, bool throwOnError = true)
        {
            using (var request = new HttpRequestMessage())
            {
                request.RequestUri = 
                    Marshalling.BuildRequestUri("/v3/workitems/{id}", 
                        routeParameters: new Dictionary<string, object> {
                            { "id", id},
                        },
                        queryParameters: new Dictionary<string, object> {
                        }
                    );

                request.Headers.TryAddWithoutValidation("Accept", "application/json");
                if (headers!=null)
                {
                    foreach (var header in headers)
                    {
                        request.Headers.TryAddWithoutValidation(header.Key, header.Value);
                    }
                }


                // tell the underlying pipeline what scope we'd like to use
                if (scopes == null)
                {
                    request.Properties.Add(ForgeConfiguration.ScopeKey, "code:all");
                }
                else
                {
                    request.Properties.Add(ForgeConfiguration.ScopeKey, scopes);
                }

                request.Method = new HttpMethod("DELETE");

                // make the HTTP request
                var response = await this.Service.Client.SendAsync(request);

                if (throwOnError)
                {
                    await response.EnsureSuccessStatusCodeAsync();
                }
                else if (!response.IsSuccessStatusCode)
                {
                    return response;
                }

                return response;

            } // using
        }
        /// <summary>
        /// Gets the status of a specific WorkItem. Gets the status of a specific WorkItem.  Typically used to &#39;poll&#39; for              the completion of a WorkItem, but see the use of the &#39;onComplete&#39; argument for              an alternative that does not require &#39;polling&#39;.  WorkItem status is retained              for a limited period of time after the WorkItem completes.              Limits:              1. Retention period (LimitWorkItemRetentionPeriod).
        /// </summary>
        /// <exception cref="HttpRequestException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>Task of ApiResponse<WorkItemStatus></returns>
        
        public async System.Threading.Tasks.Task<ApiResponse<WorkItemStatus>> GetWorkitemStatusAsync (string id, string scopes = null, IDictionary<string, string> headers = null, bool throwOnError = true)
        {
            using (var request = new HttpRequestMessage())
            {
                request.RequestUri = 
                    Marshalling.BuildRequestUri("/v3/workitems/{id}", 
                        routeParameters: new Dictionary<string, object> {
                            { "id", id},
                        },
                        queryParameters: new Dictionary<string, object> {
                        }
                    );

                request.Headers.TryAddWithoutValidation("Accept", "application/json");
                if (headers!=null)
                {
                    foreach (var header in headers)
                    {
                        request.Headers.TryAddWithoutValidation(header.Key, header.Value);
                    }
                }


                // tell the underlying pipeline what scope we'd like to use
                if (scopes == null)
                {
                    request.Properties.Add(ForgeConfiguration.ScopeKey, "code:all");
                }
                else
                {
                    request.Properties.Add(ForgeConfiguration.ScopeKey, scopes);
                }

                request.Method = new HttpMethod("GET");

                // make the HTTP request
                var response = await this.Service.Client.SendAsync(request);

                if (throwOnError)
                {
                    await response.EnsureSuccessStatusCodeAsync();
                }
                else if (!response.IsSuccessStatusCode)
                {
                    return new ApiResponse<WorkItemStatus>(response, default(WorkItemStatus));
                }

                return new ApiResponse<WorkItemStatus>(response, await Marshalling.DeserializeAsync<WorkItemStatus>(response.Content));

            } // using
        }
    }
}
